
** Conflict (reduce/reduce) in state 2347.
** Tokens involved: TComma TCPar
** The following explanations concentrate on token TComma.
** This state is reached from minus_main after reading:

loption(filespec) fninfo TFunDecl fn_ident topar TMeta 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

minus_main 
minus_body EOF 
loption(filespec) loption(minus_start) 
                  minus_start 
                  fundecl 
                  single_fundecl 
                  fninfo TFunDecl fn_ident topar arg_list(decl_typedef) tcpar TOBrace fun_start TCBrace 
                                                 reverse_separated_nonempty_llist(TComma,argorellipsis(one_arg(decl_typedef))) 
                                                 reverse_separated_nonempty_llist(TComma,argorellipsis(one_arg(decl_typedef))) TComma argorellipsis(one_arg(decl_typedef)) // lookahead token appears
                                                 argorellipsis(one_arg(decl_typedef)) // lookahead token is inherited
                                                 one_arg(decl_typedef) // lookahead token is inherited
                                                 decl_typedef // lookahead token is inherited
                                                 (?)

** In state 2347, looking ahead at TComma, reducing production
** decl_typedef -> TMeta 
** is permitted because of the following sub-derivation:

TMeta . 

** In state 2347, looking ahead at TComma, reducing production
** typedef_ident_typename -> TMeta 
** is permitted because of the following sub-derivation:

typedef_ident_typename // lookahead token is inherited
TMeta . 

** Conflict (reduce/reduce) in state 2326.
** Tokens involved: Tstatic Tregister Tinline Textern Tauto Tattr TFunDecl
** The following explanations concentrate on token Tstatic.
** This state is reached from minus_main after reading:

loption(filespec) TMeta 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

minus_main 
minus_body EOF 
loption(filespec) loption(minus_start) 
                  minus_start 
                  (?)

** In state 2326, looking ahead at Tstatic, reducing production
** statement -> TMeta 
** is permitted because of the following sub-derivation:

toplevel_seq_startne(toplevel_after_dots_init) 
decl_statement_expr toplevel_after_stm // lookahead token appears because toplevel_after_stm can begin with Tstatic
statement // lookahead token is inherited
TMeta . 

** In state 2326, looking ahead at Tstatic, reducing production
** typedef_ident_typename -> TMeta 
** is permitted because of the following sub-derivation:

fundecl 
single_fundecl 
fninfo TFunDecl fn_ident topar arg_list(decl_typedef) tcpar TOBrace fun_start TCBrace 
typedef_ident_typename fninfo_nt // lookahead token appears because fninfo_nt can begin with Tstatic
TMeta . 

** Conflict (reduce/reduce) in state 2294.
** Tokens involved: Tstatic Tregister Tinline Textern Tauto Tattr TSymId TOPar0 TOPar TMetaId TMeta TIdentWithParentConstraint TIdent TFunDecl TComma TCPar
** The following explanations concentrate on token Tstatic.
** This state is reached from minus_main after reading:

loption(filespec) TMetaType 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

minus_main 
minus_body EOF 
loption(filespec) loption(minus_start) 
                  minus_start 
                  fundecl 
                  single_fundecl 
                  fninfo TFunDecl fn_ident topar arg_list(decl_typedef) tcpar TOBrace fun_start TCBrace 
                  typedef_ident_typename fninfo_nt // lookahead token appears because fninfo_nt can begin with Tstatic
                  (?)

** In state 2294, looking ahead at Tstatic, reducing production
** signable_types_no_ident -> TMetaType 
** is permitted because of the following sub-derivation:

ctype // lookahead token is inherited
all_basic_types list(mul) // lookahead token is inherited because list(mul) can vanish
signable_types // lookahead token is inherited
signable_types_no_ident // lookahead token is inherited
TMetaType . 

** In state 2294, looking ahead at Tstatic, reducing production
** typedef_ident_typename -> TMetaType 
** is permitted because of the following sub-derivation:

TMetaType . 

** Conflict (reduce/reduce) in state 2293.
** Tokens involved: Tstatic Tregister Tinline Textern Tauto Tattr TSymId TOPar0 TOPar TMetaId TMeta TIdentWithParentConstraint TIdent TFunDecl TComma TCPar
** The following explanations concentrate on token Tstatic.
** This state is reached from minus_main after reading:

loption(filespec) TTypeId 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

minus_main 
minus_body EOF 
loption(filespec) loption(minus_start) 
                  minus_start 
                  fundecl 
                  single_fundecl 
                  fninfo TFunDecl fn_ident topar arg_list(decl_typedef) tcpar TOBrace fun_start TCBrace 
                  typedef_ident_typename fninfo_nt // lookahead token appears because fninfo_nt can begin with Tstatic
                  (?)

** In state 2293, looking ahead at Tstatic, reducing production
** non_signable_types -> TTypeId 
** is permitted because of the following sub-derivation:

ctype // lookahead token is inherited
all_basic_types list(mul) // lookahead token is inherited because list(mul) can vanish
non_signable_types // lookahead token is inherited
TTypeId . 

** In state 2293, looking ahead at Tstatic, reducing production
** typedef_ident_typename -> TTypeId 
** is permitted because of the following sub-derivation:

TTypeId . 

** Conflict (shift/reduce) in state 849.
** Tokens involved: TPtrOp TOPar TOCro TInc TDot TDec
** The following explanations concentrate on token TPtrOp.
** This state is reached from iso_main after reading:

TIsoToTestExpression TNew postfix_expr(eexpr,dot_expressions) 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

iso_main 
TIsoToTestExpression eexpr list(iso(eexpr)) EOF 
                     pre_basic_expr(eexpr,dot_expressions) 
                     basic_expr(eexpr,dot_expressions) 
                     assign_expr(eexpr,dot_expressions) 
                     unary_expr(eexpr,dot_expressions) TOpAssign assign_expr_bis 
                     postfix_expr(eexpr,dot_expressions) 
                     (?)

** In state 849, looking ahead at TPtrOp, shifting is permitted
** because of the following sub-derivation:

TNew postfix_expr(eexpr,dot_expressions) 
     postfix_expr(eexpr,dot_expressions) . TPtrOp disj_ident 

** In state 849, looking ahead at TPtrOp, reducing production
** postfix_expr(eexpr,dot_expressions) -> TNew postfix_expr(eexpr,dot_expressions) 
** is permitted because of the following sub-derivation:

postfix_expr(eexpr,dot_expressions) TPtrOp disj_ident // lookahead token appears
TNew postfix_expr(eexpr,dot_expressions) . 

** Conflict (shift/reduce) in state 709.
** Tokens involved: TPtrOp TOPar TOCro TInc TDot TDec
** The following explanations concentrate on token TPtrOp.
** This state is reached from iso_main after reading:

TIsoTopLevel TNew postfix_expr(expr,invalid) 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

iso_main 
TIsoTopLevel nest_start list(iso(nest_start)) EOF 
             nest_after_dots 
             expr nest_after_exp 
             pre_basic_expr(expr,invalid) 
             basic_expr(expr,invalid) 
             assign_expr(expr,invalid) 
             unary_expr(expr,invalid) TOpAssign assign_expr_bis 
             postfix_expr(expr,invalid) 
             (?)

** In state 709, looking ahead at TPtrOp, shifting is permitted
** because of the following sub-derivation:

TNew postfix_expr(expr,invalid) 
     postfix_expr(expr,invalid) . TPtrOp disj_ident 

** In state 709, looking ahead at TPtrOp, reducing production
** postfix_expr(expr,invalid) -> TNew postfix_expr(expr,invalid) 
** is permitted because of the following sub-derivation:

postfix_expr(expr,invalid) TPtrOp disj_ident // lookahead token appears
TNew postfix_expr(expr,invalid) . 

** Conflict (shift/reduce) in state 656.
** Tokens involved: TPtrOp TOPar TOCro TInc TDot TDec
** The following explanations concentrate on token TPtrOp.
** This state is reached from iso_main after reading:

TIsoToTestExpression TPOEllipsis TNew postfix_expr(eexpr,nest_expressions) 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

iso_main 
TIsoToTestExpression eexpr list(iso(eexpr)) EOF 
                     pre_basic_expr(eexpr,dot_expressions) 
                     basic_expr(eexpr,dot_expressions) 
                     assign_expr(eexpr,dot_expressions) 
                     unary_expr(eexpr,dot_expressions) TOpAssign assign_expr_bis 
                     postfix_expr(eexpr,dot_expressions) 
                     primary_expr(eexpr,dot_expressions) 
                     dot_expressions 
                     nest_expressions 
                     TPOEllipsis expr_dots(TEllipsis) TPCEllipsis 
                                 no_dot_start_end(dexpr,edots_when(TEllipsis,eexpr)) 
                                 dexpr list(pair(edots_when(TEllipsis,eexpr),dexpr)) 
                                 pre_basic_expr(eexpr,nest_expressions) 
                                 basic_expr(eexpr,nest_expressions) 
                                 assign_expr(eexpr,nest_expressions) 
                                 unary_expr(eexpr,nest_expressions) TOpAssign assign_expr_bis 
                                 postfix_expr(eexpr,nest_expressions) 
                                 (?)

** In state 656, looking ahead at TPtrOp, shifting is permitted
** because of the following sub-derivation:

TNew postfix_expr(eexpr,nest_expressions) 
     postfix_expr(eexpr,nest_expressions) . TPtrOp disj_ident 

** In state 656, looking ahead at TPtrOp, reducing production
** postfix_expr(eexpr,nest_expressions) -> TNew postfix_expr(eexpr,nest_expressions) 
** is permitted because of the following sub-derivation:

postfix_expr(eexpr,nest_expressions) TPtrOp disj_ident // lookahead token appears
TNew postfix_expr(eexpr,nest_expressions) . 

** Conflict (shift/reduce) in state 647.
** Tokens involved: TPtrOp TOPar TOCro TInc TDot TDec
** The following explanations concentrate on token TPtrOp.
** This state is reached from minus_main after reading:

loption(filespec) TOInit TNew postfix_expr(eexpr,invalid) 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

minus_main 
minus_body EOF 
loption(filespec) loption(minus_start) 
                  minus_start 
                  top_init 
                  TOInit initialize_list TCBrace 
                         empty_list_start(initialize2,edots_when(TEllipsis,initialize)) 
                         nonempty_list_start(initialize2,edots_when(TEllipsis,initialize)) 
                         initialize2 
                         arith_expr(eexpr,invalid) 
                         cast_expr(eexpr,invalid) 
                         unary_expr(eexpr,invalid) 
                         postfix_expr(eexpr,invalid) 
                         (?)

** In state 647, looking ahead at TPtrOp, shifting is permitted
** because of the following sub-derivation:

TNew postfix_expr(eexpr,invalid) 
     postfix_expr(eexpr,invalid) . TPtrOp disj_ident 

** In state 647, looking ahead at TPtrOp, reducing production
** postfix_expr(eexpr,invalid) -> TNew postfix_expr(eexpr,invalid) 
** is permitted because of the following sub-derivation:

postfix_expr(eexpr,invalid) TPtrOp disj_ident // lookahead token appears
TNew postfix_expr(eexpr,invalid) . 
